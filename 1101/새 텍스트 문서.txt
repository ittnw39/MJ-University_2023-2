1101 객체프

--

자바 리플렉션

클래스 동적생성하기

리뷰--

mvc모델

쓰리티어 - 프로세스

정보처리 시스템

제어시스템 = 외부의 장치를 통제하는 것

모니터 - 프로세스 - 데이터 스토리지

|

키보드

프로그램은 사람과 소통이 되어야 한다. 직접 소통을 못하므로 아이오 디바이스가 달려있다. 
아이오디바이스부터 시작해서 뭔가 부탁이 들어오거나 능동적으로 외부의 데이터를 받는 경우가 있다.

수동 / 능동

정보처리시스템은 결국 저장된 데이터를 우리가 읽거나 쓰거나 가공하는 것이다. 초기의 컴퓨터 시스템은 정보처리 시스템이다.

추상화 - 규칙을 만들어내는 것

클래스로부터 오브젝트를 만들어냄. 오브젝트는 클래스의 인스턴스.

클래스는 어떻게 구성되어 있는가? = 안에 데이터를 정의하는 부분과 함수가 있다.

함수는 행위적 규칙, int x는 데이터의 구성을 이야기한다.

n개의 인스턴스를 만들 수 있다. 

코드세그먼트 - void ()
힙에 a1, a2이 생긴다. -  int x, int x 4바이트가 또 생김
함수는 코드가 세트이다.

데이터 세그먼트는 종류가 많다.

함수는 객체가 n개 있어도 하나만 있다. 코드는 항상 일정하기 때문. 데이터를 뭘 쓸거냐에 따라 안의 내용이 달라진다.

코드는 상태를 가지지 않는다. 상태는 내가 지금한 작업을 이어서 하는 것임.

시작하고 끝나면 처음부터 다시 시작한다. - 함수는 끝나던가 말던가 둘중에 하나이다.

함수는 상태를 갖지 않는다. 끝나면 메모리가 다 날라간다. 스택의 메모리가 날라감. 그러나 객체는 상태를 갖는다. 상태는 지속성이다.

상태를 유지하는 객체

리셋되어서 나오느냐 아니냐 =의 문제. 

시간적으로 데이터가 값을 이전의 값을 가지면 상태를 유지하는 것 = 객체가 닫혀있어야함.

상태가 유지되려면 닫혀있어야한다. 

함수는 리셋된다. 그 상태를 객체에 저장한다.

독립적인 컨텍스트(상태)를 유지

컨텍스트는 메모리. 메모리가 객체. 객체의 상태는 a에 저장됨.

a와는 독립된 컨텍스트를 가지고 있다. a1의 x에 저장되어있다.

특정 시점의 값.

인스턴스에이션. 데이터만 메모리로 할당

--

오감, 기억부분, 추상화하는 부분

3개로 머릿속에 나눠져있음.

뷰 - 오감

모델 - 저장

컨트롤러 - 규칙을 가지고 처리 - 프로그램, 추상화

처리하는 순서를 보면 키보드가 입력, 필요한 데이터를 모델에서 끌어서 컨트롤러에게 리턴, 아웃풋으로 보여줌.

= 일종의 프로그램.

규칙을 만들어서 키보드로 치면 일부를 컴퓨터가 수행

동적이면 시각이나 청각을 통해서 능동적으로 데이터를 받아서 스스로 판단. 컨트롤러를 스스로 만들어냄 = 딥러닝..

규칙을 시람처럼 인스턴스를 만든다.

우리의 머리와의 차이는 컨트롤에서 규칙을 만들어내는 것. 컴퓨터는 학습된 프로그램이 아니라 확정적 프로그램을 쓴다.
인스턴스에이션이 아니라 클래스케이션을 한다.

인스턴스에이션은 클래스애서 객체를 만드는 것.

인스턴스에서 클래스를 만드는 건 추상화. -> 인간이 할 수 있었으나 딥러닝이 가능함.

--

재료와 실행코드

rmi

뷰는 ui담당.

예외 처리는 바깥으로 나와야 한다.

컨트롤러와 모델에서는 키보드 등 인풋을 하면안됨.

효율적으로 하기 위해서는 기능별로 나눠야한다.

기능 - 고객의 기능, 업무적 기능(같은 업무끼리)

서비스 - 추상화시켜서 기능, 역할, 처리별로 나눠야 한다.

고객이 원하는 기능과 처리 기능을 분리.

서비스 기능은 ->
역할별 기능은 |  |  |

작은 사이즈로 다양하게 유연한 서비스를 하는게 관건.

일반적으로 쓰이는 구조가 모델 뷰 컨트롤러 구조.

저장된 데이터, 규칙, 사용자와의 소통 세가지로 나뉜다.

---

클라이언트 서버

대규모의 서비스 전문 업체 생성. - 서버

클라이언트와 서버의 문맥이 다르다.

원래 뷰에서 컨트롤러의 함수를 호출하려면 메인에서 jump하면서 객체의 주소를 알아야한다. 처음 파라미터는 객체의 주소가 들어간다.

파라미터가 a의 a1 , 

a1.x

점프 f1(a1의 메모리 주소, x) 여기서 쓰는 엑스는 에이원의 엑스

--

원래는 객체의 주소와 함수의 주소만 알면되었지만

클라이언트 서버 프로그램에서는 뷰와 컨트롤러의 컨텍스트가 다르다.

특수한 매커니즘이 필요하다. 데이터를 주고받을 떄 문제가 생길 수 있다.

네트워크 - 물리적 , 컴퓨터가 다르면 전기신호를 보내야한다. 데이터를 네트워크 카드를 통해서 표준화된 데이터를 주면 네트워크 카드가 받아서 다시 바꾼다.

물리적 디바이스가 있어야 하고 논리적인 연결은 소켓을 쓴다. 

물리적인 주소는 아이피주소, 같은 컴퓨터에 여러개의 프로세스가 있으면 여러개의 소켓을 만들 수 있다.

소켓하나가 포트넘버 하나를 갖는다. 소켓이 파일과 같은 개념이다.

파일은 시간적 통신, 소켓은 공간적 통신.

파일은 과거와 현재의 소통, 실시간이 아니다. 

소켓 프로그래밍의 문제 - 물건을 쓰는 사람과 주는 배달하는 사람은 전혀 다른 것. 그러면 연결이 물건갯수만큼 만들어짐.

수많은 배달을 한꺼번에 처리하기 위해서 같은 집에 가는 물건은 한번에 배달, 시간은 좀 더 걸린다.

배달만 전달하는 스텁과 스켈레톤. 소켓 연결만 할 수 있도록 하는 것이다. 역할을 나눈것.

스텁에 아이피, 포트넘버,.. 클라이언트 쪽에 가짜 컨트롤러 집어넣음.

매핑테이블 - 서버쪽 컨트롤러안의 내부에서 쓰는 이름을 알기 위해.

클라이언트를 만들때 api, 서비스의 이름을 인터페이스에 노출시켜놓는다.

오픈 api 를 호출할 수 있도록 프로토콜을 노출함..

클래스 하이퍼텍스트 - 연결된 텍스트

하이퍼텍스트의 목적 - 커넥션이 계속 연결되어있으면 변하지 않음. 데이터를 받고 커넥션을 끊어버린다. 커넥션을 연결하고 버리고 반복한다. 이는 해킹이 가능하다.
커넥션리스 프로그램

클라이언트가 로그인하면 토큰을 준다. 다음 로그인떄 토큰을 들고가서 스켈레톤이 넘어간다.

커넥션이 계속 유지되는경우는 해킹 불가.

게임, 은행, 카카오톡은 커넥션이 유지된다. 클로즈될떄 연결을 끊는다.

우리가 짜는 프로그램은 커넥션리스 프로그램.

rmi는 자바가 제공하는 통신

iControl

클래스를 전달해야지만 뉴를 할 수 있다.

rmi , 클래스를 주기- 받은 클래스가 new, 객체를 만들어서 날리고 복구.

오브젝트를 파일에 쓸 때, 자바는 한번에 쓸 수 있다. - 시리얼라이즈하는 함수가 있다. 그대로 읽고 쓸 수 있다. 그대로 복구함. 문제는 보낸 객체의 클래스가 뭔지를 알아야한다.
오브젝트 자체를 보낸다. - 객체이름, 함수이름, 파라미터 값-진짜 객체 // 아니면 클래스를 보내는 방법이 있다.

1. rmi
2. 객체
3. 클래스

--

컨트롤이 2가지가 있다.

state full 컨트롤 - 이전 작업의 상태를 알고 그 다음에 반영해야함.

stateless 컨트롤 - 한 번 쓰고 버린다. 이 방법을 쓰는게 시스템의 과부하가 줄어든다. 컨트롤을 full을 미리 만들어서 주고받고 한다. 그럴려면 명령어가 어토믹해야한다. <-> 트랜잭션
어토믹은 중간에 끊어진다. 

과제 1. rmi 
2. 오브젝트 시리얼라이제이션 - 읽을 때 오브젝트라는 수퍼클래스로 받을 수 있음, 클래스가 뭔지 물어봐야함.
3. 클래스 트랜지

오브젝트는 클래스도 쫓아감.

오브젝트는 메모리가 할당됨. 클래스가 같이 간다. 

클래스는 혼자 간다.

rmi는 서버에 만들어놓는다. 이름만 준다.

토큰 - 객체의 상태유지.. 

자바 리플렉션의 개념이해하기-


